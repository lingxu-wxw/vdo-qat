diff --git a/Makefile b/Makefile
index 4084615..1283adb 100644
--- a/Makefile
+++ b/Makefile
@@ -1,2 +1,4 @@
+KBUILD_EXTRA_SYMBOLS += $(ICP_ROOT)/quickassist/lookaside/access_layer/src/Module.symvers
+
 obj-y += uds/
 obj-y += vdo/
diff --git a/uds/uds.h b/uds/uds.h
index 14cf903..90d150b 100644
--- a/uds/uds.h
+++ b/uds/uds.h
@@ -79,7 +79,7 @@ typedef enum {
 
 /** General UDS constants. */
 /** The chunk name size in bytes (128 bits = 16 bytes). */
-#define UDS_CHUNK_NAME_SIZE 16
+#define UDS_CHUNK_NAME_SIZE 32
 enum {
   /** The maximum metadata size in bytes. */
   UDS_MAX_METADATA_SIZE = 16
diff --git a/vdo/Makefile b/vdo/Makefile
index a141e98..81bc8bc 100644
--- a/vdo/Makefile
+++ b/vdo/Makefile
@@ -7,7 +7,7 @@ VDO_VERSION_MICRO = $(word 3,$(subst ., ,$(VDO_VERSION)))
 SOURCES  = $(addprefix base/,$(notdir $(wildcard $(src)/base/*.c)))
 SOURCES += $(addprefix kernel/,$(notdir $(wildcard $(src)/kernel/*.c)))
 OBJECTS = $(SOURCES:%.c=%.o)
-INCLUDES = -I$(src)/base -I$(src)/kernel -I$(src)/../uds
+INCLUDES = -I$(src)/base -I$(src)/kernel -I$(src)/../uds -I$(ICP_ROOT)/quickassist/include
 
 EXTRA_CFLAGS =	-std=gnu99					\
 		-fno-builtin-memset				\
diff --git a/vdo/kernel/dataKVIO.c b/vdo/kernel/dataKVIO.c
index 358aae9..afdbe85 100644
--- a/vdo/kernel/dataKVIO.c
+++ b/vdo/kernel/dataKVIO.c
@@ -30,6 +30,7 @@
 #include "compressedBlock.h"
 #include "hashLock.h"
 #include "lz4.h"
+#include "qat.h"
 
 #include "bio.h"
 #include "dedupeIndex.h"
@@ -308,18 +309,16 @@ static void resetUserBio(BIO *bio, int error)
 
 /**
  * Uncompress the data that's just been read and then call back the requesting
- * DataKVIO.
+ * DataKVIO with QAT.
  *
  * @param workItem  The DataKVIO requesting the data
  **/
-static void uncompressReadBlock(KvdoWorkItem *workItem)
+static void uncompressReadBlockWithQAT(KvdoWorkItem *workItem)
 {
   DataKVIO  *dataKVIO  = workItemAsDataKVIO(workItem);
   ReadBlock *readBlock = &dataKVIO->readBlock;
-  BlockSize  blockSize = VDO_BLOCK_SIZE;
+  size_t blockSize = VDO_BLOCK_SIZE;
 
-  // The DataKVIO's scratch block will be used to contain the
-  // uncompressed data.
   uint16_t fragmentOffset, fragmentSize;
   char *compressedData = readBlock->data;
   int result = getCompressedBlockFragment(readBlock->mappingState,
@@ -334,16 +333,12 @@ static void uncompressReadBlock(KvdoWorkItem *workItem)
   }
 
   char *fragment = compressedData + fragmentOffset;
-  int size = LZ4_uncompress_unknownOutputSize(fragment, dataKVIO->scratchBlock,
-                                              fragmentSize, blockSize);
-  if (size == blockSize) {
-    readBlock->data = dataKVIO->scratchBlock;
-  } else {
-    logDebug("%s: lz4 error", __func__);
-    readBlock->status = VDO_INVALID_FRAGMENT;
+  int status = qat_compress(dataKVIO, QAT_DECOMPRESS, fragment, (size_t)fragmentSize, dataKVIO->scratchBlock, (size_t)VDO_BLOCK_SIZE, &blockSize);
+  if (status != CPA_STATUS_SUCCESS)
+  {
+	readBlock->status = VDO_INVALID_FRAGMENT;
+	readBlock->callback(dataKVIO);
   }
-
-  readBlock->callback(dataKVIO);
 }
 
 /**
@@ -359,7 +354,7 @@ static void completeRead(DataKVIO *dataKVIO, int result)
   readBlock->status = result;
 
   if ((result == VDO_SUCCESS) && isCompressed(readBlock->mappingState)) {
-    launchDataKVIOOnCPUQueue(dataKVIO, uncompressReadBlock, NULL,
+    launchDataKVIOOnCPUQueue(dataKVIO, uncompressReadBlockWithQAT, NULL,
                              CPU_Q_ACTION_COMPRESS_BLOCK);
     return;
   }
@@ -534,35 +529,25 @@ void kvdoCopyDataVIO(DataVIO *source, DataVIO *destination)
 }
 
 /**********************************************************************/
-static void kvdoCompressWork(KvdoWorkItem *item)
+static void kvdoCompressWorkWithQAT(KvdoWorkItem *item)
 {
   DataKVIO    *dataKVIO = workItemAsDataKVIO(item);
-  KernelLayer *layer    = getLayerFromDataKVIO(dataKVIO);
   dataKVIOAddTraceRecord(dataKVIO, THIS_LOCATION(NULL));
 
-  char *context = getWorkQueuePrivateData();
-  if (unlikely(context == NULL)) {
-    uint32_t index = atomicAdd32(&layer->compressionContextIndex, 1) - 1;
-    BUG_ON(index >= layer->deviceConfig->threadCounts.cpuThreads);
-    context = layer->compressionContext[index];
-    setWorkQueuePrivateData(context);
-  }
-
-  int size = LZ4_compress_ctx_limitedOutput(context, dataKVIO->dataBlock,
-                                            dataKVIO->scratchBlock,
-                                            VDO_BLOCK_SIZE,
-                                            VDO_BLOCK_SIZE);
-  DataVIO *dataVIO = &dataKVIO->dataVIO;
-  if (size > 0) {
-    // The scratch block will be used to contain the compressed data.
-    dataVIO->compression.data = dataKVIO->scratchBlock;
-    dataVIO->compression.size = size;
-  } else {
-    // Use block size plus one as an indicator for uncompressible data.
+  size_t destLen = (size_t)VDO_BLOCK_SIZE;
+  // setCallback(dataKVIO, callback);
+  int status = qat_compress(dataKVIO, QAT_COMPRESS, 
+                      dataKVIO->dataBlock, 
+                      (size_t)VDO_BLOCK_SIZE, 
+                      dataKVIO->scratchBlock,
+                      (size_t)VDO_BLOCK_SIZE,
+                      &destLen);
+
+  if (status != CPA_STATUS_SUCCESS) {  
+    DataVIO *dataVIO = &dataKVIO->dataVIO;
     dataVIO->compression.size = VDO_BLOCK_SIZE + 1;
+    kvdoEnqueueDataVIOCallback(dataKVIO);
   }
-
-  kvdoEnqueueDataVIOCallback(dataKVIO);
 }
 
 /**********************************************************************/
@@ -585,7 +570,7 @@ void kvdoCompressDataVIO(DataVIO *dataVIO)
     return;
   }
 
-  launchDataKVIOOnCPUQueue(dataKVIO, kvdoCompressWork, NULL,
+  launchDataKVIOOnCPUQueue(dataKVIO, kvdoCompressWorkWithQAT, NULL,
                            CPU_Q_ACTION_COMPRESS_BLOCK);
 }
 
@@ -856,18 +841,18 @@ int kvdoLaunchDataKVIOFromBio(KernelLayer *layer,
 }
 
 /**
- * Hash a DataKVIO and set its chunk name.
+ * Hash a DataKVIO and set its chunk name with QAT.
  *
  * @param item  The DataKVIO to be hashed
  **/
-static void kvdoHashDataWork(KvdoWorkItem *item)
+static void kvdoHashDataWorkWithQAT(KvdoWorkItem *item)
 {
   DataKVIO *dataKVIO = workItemAsDataKVIO(item);
   DataVIO  *dataVIO  = &dataKVIO->dataVIO;
   dataVIOAddTraceRecord(dataVIO, THIS_LOCATION(NULL));
 
-  MurmurHash3_x64_128(dataKVIO->dataBlock, VDO_BLOCK_SIZE, 0x62ea60be,
-                      &dataVIO->chunkName);
+  qat_checksum(VIO_CHECKSUM_SHA256, dataKVIO->dataBlock, 
+                      VDO_BLOCK_SIZE, &dataVIO->chunkName);
   dataKVIO->dedupeContext.chunkName = &dataVIO->chunkName;
 
   kvdoEnqueueDataVIOCallback(dataKVIO);
@@ -877,7 +862,7 @@ static void kvdoHashDataWork(KvdoWorkItem *item)
 void kvdoHashDataVIO(DataVIO *dataVIO)
 {
   dataVIOAddTraceRecord(dataVIO, THIS_LOCATION(NULL));
-  launchDataKVIOOnCPUQueue(dataVIOAsDataKVIO(dataVIO), kvdoHashDataWork, NULL,
+  launchDataKVIOOnCPUQueue(dataVIOAsDataKVIO(dataVIO), kvdoHashDataWorkWithQAT, NULL,
                            CPU_Q_ACTION_HASH_BLOCK);
 }
 
diff --git a/vdo/kernel/dataKVIO.h b/vdo/kernel/dataKVIO.h
index 6a4e19c..cc96004 100644
--- a/vdo/kernel/dataKVIO.h
+++ b/vdo/kernel/dataKVIO.h
@@ -25,6 +25,7 @@
 #include "dataVIO.h"
 #include "kvio.h"
 #include "uds-block.h"
+#include "qatInternals.h"
 
 typedef struct {
   /*
@@ -112,6 +113,9 @@ struct dataKVIO {
   BIO               *dataBlockBio;
   /** A block used as output during compression or uncompression. */
   char              *scratchBlock;
+
+  /** QAT callback parameter**/
+  QATCallbackTag     qatCallbackTag;
 };
 
 /**
diff --git a/vdo/kernel/kernelLayer.c b/vdo/kernel/kernelLayer.c
index 533c152..d8da8c2 100644
--- a/vdo/kernel/kernelLayer.c
+++ b/vdo/kernel/kernelLayer.c
@@ -30,6 +30,7 @@
 #include "murmur/MurmurHash3.h"
 
 #include "lz4.h"
+#include "qat.h"
 #include "releaseVersions.h"
 #include "volumeGeometry.h"
 #include "statistics.h"
@@ -799,6 +800,14 @@ int makeKernelLayer(uint64_t        startingSector,
     }
   }
 
+  result = qat_init();
+  if (result != 0)
+  {
+    *reason = "cannot initialize qat";
+    freeKernelLayer(layer);
+    return result;
+  }
+
 
   /*
    * Part 3 - Do initializations that depend upon other previous
@@ -1073,6 +1082,9 @@ void freeKernelLayer(KernelLayer *layer)
     layer->spareKVDOFlush = NULL;
     freeBatchProcessor(&layer->dataKVIOReleaser);
     removeLayerFromDeviceRegistry(layer->deviceConfig->poolName);
+    
+    qat_fini();
+    
     break;
 
   default:
diff --git a/vdo/kernel/qat.c b/vdo/kernel/qat.c
new file mode 100644
index 0000000..265a8b5
--- /dev/null
+++ b/vdo/kernel/qat.c
@@ -0,0 +1,75 @@
+/*****************************************************************************
+ *
+ *   This file is provided under GPLv2 license.  When using or
+ *   redistributing this file, you may do so under GPL v2 license.
+ * 
+ *   GPL LICENSE SUMMARY
+ *   
+ *     Copyright(c) 2007-2020 Intel Corporation. All rights reserved.
+ *   
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of version 2 of the GNU General Public License as
+ *     published by the Free Software Foundation.
+
+ *     This program is distributed in the hope that it will be useful, but
+ *     WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *     General Public License for more details.
+
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *     The full GNU General Public License is included in this distribution
+ *     in the file called LICENSE.GPL.
+
+ *     Contact Information:
+ *     Intel Corporation 
+ *****************************************************************************/
+
+#include "qat.h"
+#include "statusCodes.h"
+#include <linux/slab.h>
+
+/**********************************************************************/
+CpaStatus qat_mem_alloc_contig(void **pp_mem_addr, Cpa32U size_bytes)
+{
+	*pp_mem_addr = kmalloc(size_bytes, GFP_KERNEL);
+	if (*pp_mem_addr == NULL) {
+		return (CPA_STATUS_RESOURCE);
+	}
+	return (CPA_STATUS_SUCCESS);
+}
+
+/**********************************************************************/
+void qat_mem_free_contig(void **pp_mem_addr)
+{
+	if (*pp_mem_addr != NULL) {
+		kfree(*pp_mem_addr);
+		*pp_mem_addr = NULL;
+	}
+}
+
+/**********************************************************************/
+int qat_init(void)
+{
+	int ret;
+
+	ret = qat_dc_init();
+	if (ret != 0) {
+		return (ret);
+	}
+
+	ret = qat_cy_init();
+	if (ret != 0) {
+		return (ret);
+	}
+
+	return VDO_SUCCESS;
+}
+
+/**********************************************************************/
+void qat_fini(void)
+{
+	qat_dc_fini();
+	qat_cy_fini();
+}
diff --git a/vdo/kernel/qat.h b/vdo/kernel/qat.h
new file mode 100644
index 0000000..51e44b1
--- /dev/null
+++ b/vdo/kernel/qat.h
@@ -0,0 +1,166 @@
+/*****************************************************************************
+ *
+ *   This file is provided under GPLv2 license.  When using or
+ *   redistributing this file, you may do so under GPL v2 license.
+ * 
+ *   GPL LICENSE SUMMARY
+ *   
+ *     Copyright(c) 2007-2020 Intel Corporation. All rights reserved.
+ *   
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of version 2 of the GNU General Public License as
+ *     published by the Free Software Foundation.
+
+ *     This program is distributed in the hope that it will be useful, but
+ *     WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *     General Public License for more details.
+
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *     The full GNU General Public License is included in this distribution
+ *     in the file called LICENSE.GPL.
+
+ *     Contact Information:
+ *     Intel Corporation 
+ *****************************************************************************/
+
+#ifndef	_SYS_QAT_H
+#define	_SYS_QAT_H
+
+#include "cpa.h"
+#include "dc/cpa_dc.h"
+#include "lac/cpa_cy_sym.h"
+#include "lac/cpa_cy_im.h"
+#include "lac/cpa_cy_common.h"
+#include "dataKVIO.h"
+#include "dataVIO.h"
+#include "qatInternals.h"
+
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/pagemap.h>
+#include <linux/completion.h>
+#include <linux/atomic.h>
+
+/*
+ * The minimal and maximal buffer size which are not restricted in 
+ * the QAT hardware, but with the input buffer size between 4KB and 
+ * 128KB the hardware can provide the optimal performance.
+ */
+#define	QAT_MIN_BUF_SIZE	(4*1024)
+#define	QAT_MAX_BUF_SIZE	(128*1024)
+
+/*
+ * fake CpaStatus used to indicate data was not compressible
+ */
+#define	CPA_STATUS_INCOMPRESSIBLE				(-127)
+
+/**********************************************************************/
+/*
+ * VIO checksum types
+ */
+enum vio_checksum {
+	VIO_CHECKSUM_INHERIT = 0,
+	VIO_CHECKSUM_SHA256,
+	VIO_CHECKSUM_SHA512,
+#if !defined(__FreeBSD__)
+	VIO_CHECKSUM_EDONR,
+#endif
+	VIO_CHECKSUM_FUNCTIONS
+};
+
+/**********************************************************************/
+
+/*
+ * inlined for performance
+ */
+static inline struct page *qat_mem_to_page(void *addr)
+{
+	if (!is_vmalloc_addr(addr)) {
+		return (virt_to_page(addr));
+	}
+	return (vmalloc_to_page(addr));
+}
+
+/*
+ * QAT memory contig allocation/free
+ */
+CpaStatus qat_mem_alloc_contig(void **pp_mem_addr, Cpa32U size_bytes);
+void qat_mem_free_contig(void **pp_mem_addr);
+
+#define	QAT_PHYS_CONTIG_ALLOC(pp_mem_addr, size_bytes)	\
+	qat_mem_alloc_contig((void *)(pp_mem_addr), (size_bytes))
+#define	QAT_PHYS_CONTIG_FREE(p_mem_addr)	\
+	qat_mem_free_contig((void *)&(p_mem_addr))
+
+/**********************************************************************/
+
+/*
+ * QAT compress/decompress procedure init
+ */
+extern int qat_dc_init(void);
+
+/*
+ * QAT compress/decompress procedure finish
+ */
+extern void qat_dc_fini(void);
+
+/*
+ * QAT crpty/checksum procedure init
+ */
+extern int qat_cy_init(void);
+
+/*
+ * QAT crpty/checksum procedure finish
+ */
+extern void qat_cy_fini(void);
+
+/**
+ * QAT hardware accelerator init
+ * 
+ * @return VDO_SUCCESS or an error
+ **/
+extern int qat_init(void);
+
+/**
+ * QAT hardware accelerator finish
+ **/
+extern void qat_fini(void);
+
+/**********************************************************************/
+
+/**
+ * Use QAT to compress block.
+ *
+ * @param dataKVIO  The DataKVIO of source block 
+ * @param dir  		Compress or Decompress
+ * @param src	 	The memory address of source block
+ * @param src_len 	The length of source block
+ * @param dst 		The memory address of destination block
+ * @param dst_len	The length of destination block
+ * @param c_len		
+ *
+ * @return CPA_STATUS_SUCCESS or an error
+ **/
+extern int qat_compress(DataKVIO *dataKVIO, qat_compress_dir_t dir, 
+                        char *src, int src_len, char *dst, int dst_len, size_t *c_len);
+
+/**********************************************************************/
+
+/**
+ * Use QAT to do checkcsum.
+ *
+ * @param cksum  The checksum algorithm
+ * @param buf  		The memory address of source block
+ * @param size	 	The size of source block
+ * @param out 	A 256-bit checksum for cryptographic hashes
+ *
+ * @return CPA_STATUS_SUCCESS or an error
+ **/
+extern int qat_checksum(uint64_t cksum, uint8_t *src_buf, uint64_t size, void *out);
+
+
+#endif /* _SYS_QAT_H */
diff --git a/vdo/kernel/qatChecksum.c b/vdo/kernel/qatChecksum.c
new file mode 100644
index 0000000..86f3911
--- /dev/null
+++ b/vdo/kernel/qatChecksum.c
@@ -0,0 +1,445 @@
+/*****************************************************************************
+ *
+ *   This file is provided under GPLv2 license.  When using or
+ *   redistributing this file, you may do so under GPL v2 license.
+ * 
+ *   GPL LICENSE SUMMARY
+ *   
+ *     Copyright(c) 2007-2020 Intel Corporation. All rights reserved.
+ *   
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of version 2 of the GNU General Public License as
+ *     published by the Free Software Foundation.
+
+ *     This program is distributed in the hope that it will be useful, but
+ *     WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *     General Public License for more details.
+
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *     The full GNU General Public License is included in this distribution
+ *     in the file called LICENSE.GPL.
+
+ *     Contact Information:
+ *     Intel Corporation 
+ *****************************************************************************/
+
+#include "qat.h"
+#include "constants.h"
+#include "dataKVIO.h"
+#include "dataVIO.h"
+
+/*
+ * Max instances in a QAT device, each instance is a channel to submit jobs 
+ * to QAT hardware, this is only for pre-allocating instance and session 
+ * arrays; the actual number of instances are defined in the QAT driver's 
+ * configuration file.
+ */
+#define	QAT_CY_MAX_INSTANCES	48
+
+#define	MAX_PAGE_NUM			1024
+
+/*
+ * QAT Instance handle type
+ * Handle used to uniquely identify an instance.
+ */
+static CpaInstanceHandle inst_handles[QAT_CY_MAX_INSTANCES];
+
+/*
+ * QAT Device Instance
+ */
+static Cpa16U cy_num_inst = 0;
+static Cpa32U inst_num = 0;
+
+static boolean_t qat_cy_init_done = B_FALSE;
+
+/**********************************************************************/
+/*
+ * Function Declare
+ */
+static void qat_cy_clean(void);
+
+/**********************************************************************/
+/* 
+ * The following variables are allocated on the stack because we block
+ * until the callback comes back. If a non-blocking approach was to be
+ * used then these variables should be dynamically allocated 
+*/
+typedef struct cy_callback {
+	CpaBoolean verify_result;
+	struct completion complete;
+} cy_callback_t;
+
+/**********************************************************************/
+/*
+ * Register callback in cpaCySymInitSession()
+ */
+static void symcallback(void *p_callback, CpaStatus status, const CpaCySymOp operation,
+    void *sym_op_data, CpaBufferList *buf_list_dst, CpaBoolean verify)
+{
+	cy_callback_t *callback = p_callback;
+
+	if (callback != NULL) {
+		/* indicate that the function has been called */
+		callback->verify_result = verify;
+		complete(&callback->complete);
+	}
+}
+
+static void symSessionWaitForInflightReq(CpaCySymSessionCtx pSessionCtx)
+{
+
+/* Session reuse is available since Cryptographic API version 2.2 */
+    CpaBoolean sessionInUse = CPA_FALSE;
+    do
+    {
+        cpaCySymSessionInUse(pSessionCtx, &sessionInUse);
+    } while (sessionInUse);
+
+    return;
+}
+
+
+/**********************************************************************/
+/* 
+ * Initial step is responsible for init device instances.
+ */
+int qat_cy_init(void)
+{
+	CpaStatus status = CPA_STATUS_SUCCESS;
+
+	if (qat_cy_init_done) {
+		return (0);
+  }
+  
+  /* Get the number of device instances */
+	status = cpaCyGetNumInstances(&cy_num_inst);
+	if (status != CPA_STATUS_SUCCESS) {
+		return (-1);
+  }
+
+	/* if the user has configured no QAT encryption units just return */
+	if (cy_num_inst == 0) {
+		return (0);
+  }
+
+	if (cy_num_inst > QAT_CY_MAX_INSTANCES) {
+		cy_num_inst = QAT_CY_MAX_INSTANCES;
+  }
+
+  /* Get the device instances */
+	status = cpaCyGetInstances(cy_num_inst, &inst_handles[0]);
+	if (status != CPA_STATUS_SUCCESS) {
+		return (-1);
+  }
+
+	for (Cpa16U i = 0; i < cy_num_inst; i++) {
+    /* Set the virtual to physical address translation routine for the instance */
+		status = cpaCySetAddressTranslation(inst_handles[i], (void *)virt_to_phys);
+		if (status != CPA_STATUS_SUCCESS) {
+			goto done;
+    }
+
+    /* Cryptographic Component Initialization and Start function */
+		status = cpaCyStartInstance(inst_handles[i]);
+		if (status != CPA_STATUS_SUCCESS) {
+			goto done;
+    }
+	}
+
+	qat_cy_init_done = B_TRUE;
+	return (0);
+
+done:
+
+	qat_cy_clean();
+	return (-1);
+}
+
+/**********************************************************************/
+/* 
+ * Clean step is responsible for freeing allocated memory.
+ */
+void qat_cy_clean(void)
+{
+	for (Cpa16U i = 0; i < cy_num_inst; i++) {
+    /* Stop the Compression component and free all system resources associated with it */
+		cpaCyStopInstance(inst_handles[i]);
+  }
+
+	cy_num_inst = 0;
+	qat_cy_init_done = B_FALSE;
+}
+
+/**********************************************************************/
+/* 
+ * Final step is responsible for freeing allocated memory and sending the item 
+ * to deduplication processing module to redirect the successor module. 
+ */
+void qat_cy_fini(void)
+{
+	if (!qat_cy_init_done) {
+		return;
+  }
+
+	qat_cy_clean();
+}
+
+/**********************************************************************/
+/*
+ * Init Checksum session.
+ */
+static CpaStatus qat_init_checksum_session_ctx(CpaInstanceHandle inst_handle,
+    CpaCySymSessionCtx **cy_session_ctx, Cpa64U cksum)
+{
+	CpaStatus status = CPA_STATUS_SUCCESS;
+	Cpa32U session_ctx_size;
+	Cpa32U hash_algorithm;
+	CpaCySymSessionSetupData sd = { 0 };
+
+	/*
+	 * SHA512/256 is a different IV from standard SHA512. QAT does not 
+	 * support SHA512/256, so we can only support SHA256.
+	 */
+	if (cksum == VIO_CHECKSUM_SHA256) {
+		hash_algorithm = CPA_CY_SYM_HASH_SHA256;
+    } else {
+		return (CPA_STATUS_FAIL);
+    }
+
+	/*
+     * We now populate the fields of the session operational data and create
+     * the session.  Note that the size required to store a session is
+     * implementation-dependent, so we query the API first to determine how
+     * much memory to allocate, and then allocate that memory.
+     */
+	/* populate symmetric session data structure for a plain hash operation */
+	sd.sessionPriority = CPA_CY_PRIORITY_NORMAL;
+	sd.symOperation = CPA_CY_SYM_OP_HASH;
+	sd.hashSetupData.hashAlgorithm = hash_algorithm;
+	sd.hashSetupData.hashMode = CPA_CY_SYM_HASH_MODE_PLAIN;
+	sd.hashSetupData.digestResultLenInBytes = UDS_CHUNK_NAME_SIZE;
+	/* Place the digest result in a buffer unrelated to srcBuffer */
+	sd.digestIsAppended = CPA_FALSE;
+	/* Generate the digest */
+	sd.verifyDigest = CPA_FALSE;
+
+    /* Get the size of the memory allocated to hold the session information */
+	status = cpaCySymSessionCtxGetSize(inst_handle, &sd, &session_ctx_size);
+	if (status != CPA_STATUS_SUCCESS) {
+		return (status);
+    }
+
+    /* Allocate session context */
+	status = QAT_PHYS_CONTIG_ALLOC(cy_session_ctx, session_ctx_size);
+	if (status != CPA_STATUS_SUCCESS) {
+		return (status);
+    }
+
+    /* Initialize the Hash session */
+	status = cpaCySymInitSession(inst_handle, symcallback, 
+                              &sd, *cy_session_ctx);
+	if (status != CPA_STATUS_SUCCESS) {
+		QAT_PHYS_CONTIG_FREE(*cy_session_ctx);
+		return (status);
+	}
+
+	return (CPA_STATUS_SUCCESS);
+}
+
+/**********************************************************************/
+/*
+ * Init cryptographic buffer lists.
+ */
+static CpaStatus qat_init_cy_buffer_lists(CpaInstanceHandle inst_handle, 
+    uint32_t nr_bufs, CpaBufferList *src, CpaBufferList *dst)
+{
+	CpaStatus status = CPA_STATUS_SUCCESS;
+	Cpa32U meta_size = 0;
+
+    /* build source metadata buffer list */
+	status = cpaCyBufferListGetMetaSize(inst_handle, nr_bufs, &meta_size);
+	if (status != CPA_STATUS_SUCCESS) {
+		return (status);
+    }
+
+	status = QAT_PHYS_CONTIG_ALLOC(&src->pPrivateMetaData, meta_size);
+	if (status != CPA_STATUS_SUCCESS) {
+		goto done;
+    }
+
+	if (src != dst) {
+		status = QAT_PHYS_CONTIG_ALLOC(&dst->pPrivateMetaData, meta_size);
+		if (status != CPA_STATUS_SUCCESS) {
+			goto done;
+        }
+	}
+
+	return (CPA_STATUS_SUCCESS);
+
+done:
+
+	QAT_PHYS_CONTIG_FREE(src->pPrivateMetaData);
+
+	if (src != dst) {
+		QAT_PHYS_CONTIG_FREE(dst->pPrivateMetaData);
+    }
+
+	return (status);
+}
+
+/**********************************************************************/
+/*
+ * Entry point for QAT accelerated cryptographic.
+ */
+int qat_checksum(uint64_t cksum, uint8_t *src_buf, uint64_t size, void *out)
+{
+    CpaStatus status = CPA_STATUS_SUCCESS;
+
+	CpaInstanceHandle inst_handle;
+	Cpa8U *dst_buf = NULL;
+	CpaBufferList src_buffer_list = { 0 };
+	CpaFlatBuffer *flat_src_buf_array = NULL;
+	CpaFlatBuffer *flat_src_buf = NULL;
+
+    CpaCySymSessionCtx *cy_session_ctx = NULL;
+    CpaCySymOpData sym_op_data = { 0 };
+
+	struct page *pages_in[MAX_PAGE_NUM];
+	Cpa32U page_num = 0;
+	Cpa32U page_off = 0;
+
+    Cpa32U left_bytes = 0;
+	Cpa8S *data_block = NULL;
+	cy_callback_t callback;
+
+    /* 
+	 * We increment num_bufs by 2 to allow us to handle non page-aligned 
+     * buffer addresses and buffers whose sizes are not divisible by 
+     * PAGE_SIZE. 
+	 */
+    Cpa16U nr_bufs = (size >> PAGE_SHIFT) + 2;
+
+    /* 
+	 * cy_inst_num is assigned in calling routine, in a way like round robin 
+	 * with atomic operation, to load balance for hardware instances. 
+	 */
+    Cpa16U i;
+	i = (Cpa32U)atomic_inc_return((atomic_t *)&inst_num) % cy_num_inst;
+	inst_handle = inst_handles[i];
+
+	status = qat_init_checksum_session_ctx(inst_handle, &cy_session_ctx, cksum);
+	if (status != CPA_STATUS_SUCCESS) {
+		return (status);
+	}
+
+	/* Init Buffer Lists and Allocate Memory */
+	status = qat_init_cy_buffer_lists(inst_handle, nr_bufs, &src_buffer_list, &src_buffer_list);
+	if (status != CPA_STATUS_SUCCESS) {
+		goto done;
+    }
+
+	/* Allocate Memory for source buffer array */
+	status = QAT_PHYS_CONTIG_ALLOC(&flat_src_buf_array, nr_bufs * sizeof(CpaFlatBuffer));
+	if (status != CPA_STATUS_SUCCESS) {
+		goto done;
+    }
+
+	/* Each block has a 256-bit checksum -- strong enough for cryptographic hashes. */
+	status = QAT_PHYS_CONTIG_ALLOC(&dst_buf, UDS_CHUNK_NAME_SIZE);
+	if (status != CPA_STATUS_SUCCESS) {
+		goto done;
+    }
+
+	/* Tranverse the data block by pages */
+	flat_src_buf = flat_src_buf_array;
+	data_block = src_buf;
+	left_bytes = size;
+
+	while (left_bytes > 0) {
+		/* Get current data block */
+		page_off = ((long)data_block & ~PAGE_MASK);
+		pages_in[page_num] = qat_mem_to_page(data_block);
+
+		flat_src_buf->pData = kmap(pages_in[page_num]) + page_off;
+		flat_src_buf->dataLenInBytes = min((long)PAGE_SIZE - page_off, (long)left_bytes);
+
+		/* Update current data block and left bytes */
+		data_block += flat_src_buf->dataLenInBytes;
+		left_bytes -= flat_src_buf->dataLenInBytes;
+		
+		flat_src_buf += 1;
+		page_num += 1;
+	}
+
+	/* Update Operation Data */
+	sym_op_data.sessionCtx = cy_session_ctx;
+	sym_op_data.packetType = CPA_CY_SYM_PACKET_TYPE_FULL;
+	sym_op_data.pDigestResult = dst_buf;
+	sym_op_data.hashStartSrcOffsetInBytes = 0;
+	sym_op_data.messageLenToHashInBytes = size;
+
+	/* Update source buffer list */
+	src_buffer_list.numBuffers = page_num;
+	src_buffer_list.pBuffers = flat_src_buf_array;
+
+	/* Update cryptographic callback */
+	callback.verify_result = CPA_FALSE;
+
+	/* 
+	* initialisation for callback; the "complete" variable is used by the
+	* callback function to indicate it has been called
+	*/
+	init_completion(&callback.complete);
+
+	/* Perform symmetric operation */
+	do {
+		status = cpaCySymPerformOp(
+			inst_handle, 
+			&callback, 		/* data sent as is to the callback function*/
+			&sym_op_data,		/* operational data struct */
+			&src_buffer_list,	/* source buffer list */
+			&src_buffer_list, 	/* same src & dst for an in-place operation*/
+			NULL);
+	} while (status == CPA_STATUS_RETRY);
+
+	if (status != CPA_STATUS_SUCCESS) {
+		goto done;
+	}
+
+	/* we now wait until the completion of the operation. */
+	wait_for_completion(&callback.complete);
+
+	if (callback.verify_result == CPA_FALSE) {
+		status = CPA_STATUS_FAIL;
+		goto done;
+	}
+
+    memmove(out, dst_buf, UDS_CHUNK_NAME_SIZE);
+
+done:
+
+	for (i = 0; i < page_num; i++) {
+		kunmap(pages_in[i]);
+    }
+
+	/* Wait for inflight requests before removing session */
+	symSessionWaitForInflightReq(cy_session_ctx);
+
+    /* Remove the session - session init has already succeeded */
+	cpaCySymRemoveSession(inst_handle, cy_session_ctx);
+	
+	/* 
+	 * At this stage, the callback function should have returned,
+     * so it is safe to free the memory 
+	 */
+    QAT_PHYS_CONTIG_FREE(dst_buf);
+	QAT_PHYS_CONTIG_FREE(src_buffer_list.pPrivateMetaData);
+	QAT_PHYS_CONTIG_FREE(cy_session_ctx);
+	QAT_PHYS_CONTIG_FREE(flat_src_buf_array);
+
+	return (status);
+}
+
diff --git a/vdo/kernel/qatCompress.c b/vdo/kernel/qatCompress.c
new file mode 100644
index 0000000..5b9b329
--- /dev/null
+++ b/vdo/kernel/qatCompress.c
@@ -0,0 +1,631 @@
+/*****************************************************************************
+ *
+ *   This file is provided under GPLv2 license.  When using or
+ *   redistributing this file, you may do so under GPL v2 license.
+ * 
+ *   GPL LICENSE SUMMARY
+ *   
+ *     Copyright(c) 2007-2020 Intel Corporation. All rights reserved.
+ *   
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of version 2 of the GNU General Public License as
+ *     published by the Free Software Foundation.
+
+ *     This program is distributed in the hope that it will be useful, but
+ *     WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *     General Public License for more details.
+
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *     The full GNU General Public License is included in this distribution
+ *     in the file called LICENSE.GPL.
+
+ *     Contact Information:
+ *     Intel Corporation 
+ *****************************************************************************/
+
+#include "qat.h"
+#include "constants.h"
+#include "dataKVIO.h"
+#include "dataVIO.h"
+
+/*
+ * Max instances in a QAT device, each instance is a channel to submit jobs 
+ * to QAT hardware, this is only for pre-allocating instance and session 
+ * arrays; the actual number of instances are defined in the QAT driver's 
+ * configuration file.
+ */
+#define	QAT_DC_MAX_INSTANCES	48
+
+/*
+ * ZLIB head and foot size
+ */
+#define	ZLIB_HEAD_SZ		2
+#define	ZLIB_FOOT_SZ		4
+
+/*
+ * QAT Instance handle type
+ * Handle used to uniquely identify an instance.
+ */
+static CpaInstanceHandle inst_handles[QAT_DC_MAX_INSTANCES];
+
+/*
+ * QAT Compression API session handle type
+ * Handle used to uniquely identify a Compression API session handle.
+ */
+static CpaDcSessionHandle dc_session_handles[QAT_DC_MAX_INSTANCES];
+
+/*
+ * Scatter/Gather buffer list containing an array of flat buffers.
+ */
+static CpaBufferList **buffer_array[QAT_DC_MAX_INSTANCES];
+
+/*
+ * QAT Device Instance
+ */
+static Cpa16U dc_num_inst = 0;
+static Cpa32U inst_num = 0;
+
+static boolean_t qat_dc_init_done = B_FALSE;
+static struct kmem_cache *qat_add_cache;
+
+/**********************************************************************/
+/*
+ * Function Declare
+ */
+static void qat_dc_clean(void);
+static void qat_dc_callback(void *p_callback, CpaStatus status);
+
+/**********************************************************************/
+static void *qat_add_cache_alloc(void)
+{
+	return (kmem_cache_alloc(qat_add_cache, GFP_KERNEL));
+}
+
+/**********************************************************************/
+static void qat_add_cache_free(void *add_cache)
+{
+	kmem_cache_free(qat_add_cache, add_cache);
+}
+
+/**********************************************************************/
+/* 
+ * Initial step is responsible for init device instances, init allocated memory
+ * and register callback function qat_dc_callback(). 
+ */
+int qat_dc_init(void)
+{
+	CpaStatus status = CPA_STATUS_SUCCESS;
+	Cpa32U session_size = 0;
+	Cpa32U ctx_size = 0;
+	Cpa16U num_inter_buffer_lists = 0;
+	Cpa16U buffer_num = 0;
+	Cpa32U buffer_meta_size = 0;
+	CpaDcSessionSetupData sd = {0};
+
+	if (qat_dc_init_done) {
+		return (0);
+  }
+
+	/* Get the number of device instances */
+	status = cpaDcGetNumInstances(&dc_num_inst);
+	if (status != CPA_STATUS_SUCCESS) {
+		return (-1);
+	}
+
+	/* if the user has configured no QAT compression units just return */
+	if (dc_num_inst == 0) {
+		return (0);
+	}
+
+	if (dc_num_inst > QAT_DC_MAX_INSTANCES) {
+		dc_num_inst = QAT_DC_MAX_INSTANCES;
+	}
+
+	/* Get the device instances */
+	status = cpaDcGetInstances(dc_num_inst, &inst_handles[0]);
+	if (status != CPA_STATUS_SUCCESS) {
+		return (-1);
+	}
+
+	for (Cpa16U i = 0; i < dc_num_inst; i++) {
+		/* Set the virtual to physical address translation routine for the instance */
+		cpaDcSetAddressTranslation(inst_handles[i], (void*)virt_to_phys);
+
+		status = cpaDcBufferListGetMetaSize(inst_handles[i], 1,
+                                        &buffer_meta_size);
+
+		/* Determine the number of intermediate buffer lists required by compression instance */
+		if (status == CPA_STATUS_SUCCESS) {
+			status = cpaDcGetNumIntermediateBuffers(inst_handles[i], 
+                                              &num_inter_buffer_lists);
+		}
+
+		if (status == CPA_STATUS_SUCCESS && num_inter_buffer_lists != 0) {
+			status = QAT_PHYS_CONTIG_ALLOC(
+				&buffer_array[i], num_inter_buffer_lists * sizeof (CpaBufferList *));
+		}
+
+		/* Init CpaFlatBuffer */
+		for (buffer_num = 0; buffer_num < num_inter_buffer_lists; buffer_num++) {
+			if (status == CPA_STATUS_SUCCESS) {
+				status = QAT_PHYS_CONTIG_ALLOC(
+					&buffer_array[i][buffer_num], sizeof (CpaBufferList));
+			}
+
+			if (status == CPA_STATUS_SUCCESS) {
+				status = QAT_PHYS_CONTIG_ALLOC(
+					&buffer_array[i][buffer_num]->pPrivateMetaData, buffer_meta_size);
+			}
+
+			if (status == CPA_STATUS_SUCCESS) {
+				status = QAT_PHYS_CONTIG_ALLOC(
+					&buffer_array[i][buffer_num]->pBuffers, sizeof (CpaFlatBuffer));
+			}
+
+			/*
+			 *  implementation requires an intermediate buffer approximately 
+			 *  twice the size of output buffer, which is 2x max buffer size here.
+			 */
+			if (status == CPA_STATUS_SUCCESS) {
+				status = QAT_PHYS_CONTIG_ALLOC(
+					&buffer_array[i][buffer_num]->pBuffers->pData, 2 * QAT_MAX_BUF_SIZE);
+				if (status != CPA_STATUS_SUCCESS) {
+					goto done;
+				}
+
+				buffer_array[i][buffer_num]->numBuffers = 1;
+				buffer_array[i][buffer_num]->pBuffers-> dataLenInBytes = 2 * QAT_MAX_BUF_SIZE;
+			}
+		}
+
+		/* Compression Component Initialization and Start function */
+		status = cpaDcStartInstance(inst_handles[i], 
+                                num_inter_buffer_lists, 
+                                buffer_array[i]);
+		if (status != CPA_STATUS_SUCCESS) {
+			goto done;
+		}
+
+		/* Complete the information in CpaDcSessionSetupData to setup a session */
+		sd.compLevel = CPA_DC_L1;
+		sd.compType = CPA_DC_DEFLATE;
+		sd.huffType = CPA_DC_HT_FULL_DYNAMIC;
+		sd.sessDirection = CPA_DC_DIR_COMBINED;
+		sd.sessState = CPA_DC_STATELESS;
+		sd.deflateWindowSize = 7;
+		sd.checksum = CPA_DC_ADLER32;
+
+		/* Get the size of the memory required to hold the session information */
+		status = cpaDcGetSessionSize(inst_handles[i], &sd, 
+                                     &session_size, &ctx_size);
+		if (status != CPA_STATUS_SUCCESS) {
+			goto done;
+		}
+
+		QAT_PHYS_CONTIG_ALLOC(&dc_session_handles[i], session_size);
+		if (dc_session_handles[i] == NULL) {
+			goto done;
+		}
+
+		/* 
+		 * Initialize compression or decompression session
+		 * Register callback function qat_dc_callback() 
+		 */
+		status = cpaDcInitSession(inst_handles[i], dc_session_handles[i], 
+                              &sd, NULL, qat_dc_callback);
+		if (status != CPA_STATUS_SUCCESS) {
+			goto done;
+		}
+	}
+
+	qat_add_cache = kmem_cache_create("qat_add_cache", (size_t)VDO_BLOCK_SIZE, 0, 0, NULL);
+	if (!qat_add_cache) {
+		goto done;
+	}
+
+	qat_dc_init_done = B_TRUE;
+	return (0);
+
+done:
+
+	qat_dc_clean();
+	return (-1);
+}
+
+/**********************************************************************/
+/* 
+ * Clean step is responsible for freeing allocated memory.
+ */
+static void qat_dc_clean(void)
+{
+	Cpa16U buffer_num = 0;
+	Cpa16U num_inter_buffer_lists = 0;
+
+	for (Cpa16U i = 0; i < dc_num_inst; i++) {
+		/* Stop the Compression component and free all system resources associated with it */
+		cpaDcStopInstance(inst_handles[i]);
+		QAT_PHYS_CONTIG_FREE(dc_session_handles[i]);
+
+		if (buffer_array[i] != NULL) {
+			/* 
+			 * Determine the number of intermediate buffer lists required by 
+			 * a compression instance. 
+			 */
+			cpaDcGetNumIntermediateBuffers(inst_handles[i], 
+                    				&num_inter_buffer_lists);
+		
+			/* free intermediate buffers  */
+			for (buffer_num = 0; buffer_num < num_inter_buffer_lists; buffer_num++) {
+				CpaBufferList *buffer_inter = buffer_array[i][buffer_num];
+				
+				if (buffer_inter->pBuffers) {
+					QAT_PHYS_CONTIG_FREE(buffer_inter->pBuffers->pData);
+					QAT_PHYS_CONTIG_FREE(buffer_inter->pBuffers);
+				}
+				
+				QAT_PHYS_CONTIG_FREE(buffer_inter->pPrivateMetaData);
+				QAT_PHYS_CONTIG_FREE(buffer_inter);
+			}
+		}
+	}
+
+	kmem_cache_destroy(qat_add_cache);
+	qat_add_cache = NULL;
+
+	dc_num_inst = 0;
+	qat_dc_init_done = B_FALSE;
+}
+
+/**********************************************************************/
+/* 
+ * Final step is responsible for freeing allocated memory and sending the item 
+ * to compression processing module to redirect the successor module. 
+ */
+void qat_dc_fini(void)
+{
+	if (!qat_dc_init_done) {
+		return;
+	}
+
+	qat_dc_clean();
+}
+
+/**********************************************************************/
+/* 
+ * Callback function using for QAT accelerator is registered in initialization step, 
+ * and will be invoked when hardware accelerator completes the task. 
+ * It has only two parameters, one is the pointer to callback parameter p_callback, 
+ * another is status indicates whether compression during hardware processing is successful.
+ */
+static void qat_dc_callback(void *p_callback, CpaStatus status)
+{
+	DataKVIO *dataKVIO = (DataKVIO *)p_callback;
+	QATCallbackTag *qat_p_callback = &dataKVIO->qatCallbackTag;
+	Cpa16U i = qat_p_callback->i;
+	CpaDcSessionHandle dc_session_handle;
+	dc_session_handle = dc_session_handles[i]; 
+	Cpa32U compressed_sz;
+	CpaBufferList *buffer_list_src = qat_p_callback->buffer_list_src;
+	CpaBufferList *buffer_list_dst = qat_p_callback->buffer_list_dst;
+	Cpa8U *buffer_meta_src = qat_p_callback->buffer_meta_src;
+	Cpa8U *buffer_meta_dst = qat_p_callback->buffer_meta_dst;
+	CpaFlatBuffer *flat_buffer_dst = NULL;
+	char *add = qat_p_callback->add;
+	CpaDcRqResults *dc_results = &qat_p_callback->dc_results;
+
+	DataVIO *dataVIO = &dataKVIO->dataVIO;
+	ReadBlock *readBlock = &dataKVIO->readBlock;
+
+	if (qat_p_callback->dir == QAT_COMPRESS) {
+
+		if (status != CPA_STATUS_SUCCESS) {
+			dataVIO->compression.size = VDO_BLOCK_SIZE + 1;
+			goto done;
+		}
+
+		/* In write workflow, the length of produced compressed result will be checked 
+		 * if there is enough remaining space for footer size. If no enough footer size, 
+		 * data will be marked as incompressible data similar to calling routine 
+		 * and successor procedure will be jumped and go directly to the finial step. */
+		compressed_sz = dc_results->produced;
+		if (compressed_sz + ZLIB_HEAD_SZ + ZLIB_FOOT_SZ > VDO_BLOCK_SIZE) {
+			dataVIO->compression.size = VDO_BLOCK_SIZE + 1;
+			goto done;
+		}
+
+		if (((compressed_sz + ZLIB_HEAD_SZ) % PAGE_SIZE)
+		    + ZLIB_FOOT_SZ > PAGE_SIZE) {
+			dataVIO->compression.size = VDO_BLOCK_SIZE + 1;
+			goto done;
+		}
+
+		/* Construct CpaFlatbuffer */
+		flat_buffer_dst = (CpaFlatBuffer *)(buffer_list_dst + 1);
+	
+		flat_buffer_dst->pData = (char*)((unsigned long)flat_buffer_dst->pData + (compressed_sz));
+		flat_buffer_dst->dataLenInBytes = ZLIB_FOOT_SZ;
+
+		/* A footer API is called to generate zlib style footer, 
+		 * using the same instance after retrieving dc_inst_num from QATCallbackTag. */
+		dc_results->produced = 0;
+		status = cpaDcGenerateFooter(dc_session_handle,
+		                             flat_buffer_dst, dc_results);
+		if (status != CPA_STATUS_SUCCESS) {
+			dataVIO->compression.size = VDO_BLOCK_SIZE + 1;
+			goto done;
+		}
+
+		/* Calculate the length of destination block */
+		Cpa32U destLen = compressed_sz + dc_results->produced + ZLIB_HEAD_SZ;
+
+		if (status == CPA_STATUS_SUCCESS && destLen <= VDO_BLOCK_SIZE) {	
+			/* The scratch block will be used to contain the compressed data. */
+			dataVIO->compression.data = dataKVIO->scratchBlock;
+			dataVIO->compression.size = destLen;
+		} else {
+			/* Use block size plus one as an indicator for uncompressible data. */
+			dataVIO->compression.size = VDO_BLOCK_SIZE + 1;
+			goto done;
+		} 
+	} 
+
+	else {
+		if (status != CPA_STATUS_SUCCESS) {
+			/* In read workflow, if status is not success, 
+		 	 * the status field of readBlock will be marked as invalid fragment 
+		 	 * that indicated a read failure has occurred. */
+			readBlock->status = VDO_INVALID_FRAGMENT; 
+		} else {
+			/* For decompression, input data is a compressed fragment, 
+			 * a piece of data saved in dataBlocks,
+			 * and result data are saved as scratchBlocks. */
+			readBlock->data = dataKVIO->scratchBlock;
+		}
+	}
+
+done:
+
+	QAT_PHYS_CONTIG_FREE(buffer_meta_src);
+	QAT_PHYS_CONTIG_FREE(buffer_meta_dst);
+	QAT_PHYS_CONTIG_FREE(buffer_list_src);
+	QAT_PHYS_CONTIG_FREE(buffer_list_dst);
+
+	if (qat_p_callback->dir == QAT_COMPRESS) {
+		qat_add_cache_free(add);
+		kvdoEnqueueDataVIOCallback(dataKVIO);
+	} else {
+		ReadBlock *readBlock = &dataKVIO->readBlock;
+		readBlock->callback(dataKVIO);
+	}
+}
+
+/**********************************************************************/
+/* 
+ * Calling function using for QAT accelerator will be invoked by qat_compress().
+ */
+static int qat_compress_impl(DataKVIO *dataKVIO, char *src, int src_len,
+    char *dst, int dst_len, char *add, int add_len, size_t *c_len)
+{
+  QATCallbackTag *qat_dc_callback_tag = &dataKVIO->qatCallbackTag;
+	CpaStatus status = CPA_STATUS_SUCCESS;
+	
+	CpaInstanceHandle inst_handle;
+	CpaDcSessionHandle dc_session_handle;
+	CpaBufferList *buffer_list_src = qat_dc_callback_tag->buffer_list_src;
+	CpaBufferList *buffer_list_dst = qat_dc_callback_tag->buffer_list_dst;
+	CpaFlatBuffer *flat_buffer_src = NULL;
+	CpaFlatBuffer *flat_buffer_dst = NULL;
+	Cpa8U *buffer_meta_src = qat_dc_callback_tag->buffer_meta_src;
+	Cpa8U *buffer_meta_dst = qat_dc_callback_tag->buffer_meta_dst;
+	Cpa32U buffer_meta_size = 0;
+
+	CpaDcRqResults* dc_results = &qat_dc_callback_tag->dc_results;
+	qat_compress_dir_t dir = qat_dc_callback_tag->dir;	
+
+	Cpa32U hdr_sz = 0;
+
+	/* 
+	 * We increment num_src_buf and num_dst_buf by 2 to allow
+	 * us to handle non page-aligned buffer addresses and buffers
+	 * whose sizes are not divisible by PAGE_SIZE. 
+	 */
+	Cpa32U num_src_buf = (src_len >> PAGE_SHIFT) + 2;
+	Cpa32U num_dst_buf = (dst_len >> PAGE_SHIFT) + 2;
+	Cpa32U num_add_buf = (add_len >> PAGE_SHIFT) + 2;
+	
+	/* calculate the size of buffer list */
+	Cpa32U src_buffer_list_mem_size = sizeof (CpaBufferList) +
+	    (num_src_buf * sizeof (CpaFlatBuffer));
+	Cpa32U dst_buffer_list_mem_size = sizeof (CpaBufferList) +
+	    ((num_dst_buf + num_add_buf) * sizeof (CpaFlatBuffer));
+	
+	/* 
+	 * dc_inst_num is assigned in calling routine, in a way like round robin 
+	 * with atomic operation, to load balance for hardware instances. 
+	 */
+	Cpa16U i;
+	i = (Cpa32U)atomic_inc_return((atomic_t *)&inst_num) % dc_num_inst;
+	inst_handle = inst_handles[i];
+	dc_session_handle = dc_session_handles[i];
+
+	/* build source metadata buffer list */
+	cpaDcBufferListGetMetaSize(inst_handle, num_src_buf,
+                             &buffer_meta_size);
+
+	status = QAT_PHYS_CONTIG_ALLOC(&buffer_meta_src, buffer_meta_size);
+	if (status != CPA_STATUS_SUCCESS) {
+		goto done;
+	}
+
+	/* build destination metadata buffer list */
+	cpaDcBufferListGetMetaSize(inst_handle, num_dst_buf + num_add_buf,
+	                           &buffer_meta_size);
+
+	status = QAT_PHYS_CONTIG_ALLOC(&buffer_meta_dst, buffer_meta_size);
+	if (status != CPA_STATUS_SUCCESS) {
+		goto done;
+	}
+
+	/* build source buffer list */
+	status = QAT_PHYS_CONTIG_ALLOC(&buffer_list_src, src_buffer_list_mem_size);
+	if (status != CPA_STATUS_SUCCESS) {
+		goto done;
+	}
+	
+	/* always point to first one */
+	flat_buffer_src = (CpaFlatBuffer *)(buffer_list_src + 1);
+	buffer_list_src->pBuffers = flat_buffer_src;
+
+	/* build destination buffer list */
+	status = QAT_PHYS_CONTIG_ALLOC(&buffer_list_dst, dst_buffer_list_mem_size);
+	if (status != CPA_STATUS_SUCCESS) {
+		goto done;
+	}
+
+	/* always point to first one */
+	flat_buffer_dst = (CpaFlatBuffer *)(buffer_list_dst + 1);
+	buffer_list_dst->pBuffers = flat_buffer_dst;
+
+	buffer_list_src->numBuffers = 1;
+	buffer_list_src->pPrivateMetaData = buffer_meta_src;
+	flat_buffer_src->pData = src;
+	flat_buffer_src->dataLenInBytes = src_len;
+
+	buffer_list_dst->numBuffers = 1;
+	buffer_list_dst->pPrivateMetaData = buffer_meta_dst;
+	flat_buffer_dst->pData = dst;
+	flat_buffer_dst->dataLenInBytes = dst_len;
+	
+	qat_dc_callback_tag->buffer_meta_src = buffer_meta_src;
+	qat_dc_callback_tag->buffer_meta_dst = buffer_meta_dst;
+	qat_dc_callback_tag->buffer_list_src = buffer_list_src;
+	qat_dc_callback_tag->buffer_list_dst = buffer_list_dst;
+
+	if (dir == QAT_COMPRESS) {
+		flat_buffer_dst++;
+		buffer_list_dst->numBuffers++;
+
+		/*
+		 * The "add" parameter is an additional buffer which is passed
+		 * to QAT as a scratch buffer alongside the destination buffer
+		 * in case the "compressed" data ends up being larger than the
+		 * original source data. This is necessary to prevent QAT from
+		 * generating buffer overflow warnings for incompressible data.
+		 */
+		flat_buffer_dst->pData = add;
+		flat_buffer_dst->dataLenInBytes = add_len;
+
+		/* 
+		 * As for compression, a header API is called to generate zlib style header.
+		 * The result will be put in the head of output buffer 
+		 * with length of zlib header, which is fixed at 2 byte. 
+		 */
+		cpaDcGenerateHeader(dc_session_handle, buffer_list_dst->pBuffers, &hdr_sz);
+		buffer_list_dst->pBuffers->pData += hdr_sz;
+		buffer_list_dst->pBuffers->dataLenInBytes -= hdr_sz;
+
+		/* 
+		 * After data and context preparation, QAT kernel API for compression is called, 
+		 * with a parameter as DataKVIO that preserving the QATCallbackTag in it. 
+		 */
+		status = cpaDcCompressData(
+		    inst_handle, dc_session_handle,
+		    buffer_list_src, buffer_list_dst,
+		    dc_results, CPA_DC_FLUSH_FINAL,
+		    dataKVIO);
+		
+		/*
+		 * Once data is successfully sent to QAT accelerator, 
+		 * the calling routine will finish this sending work and return the control back 
+		 * to compression processing module, which will be ready to access next work item 
+		 * from CPU queue and start a new sending work. 
+		 */
+		if (status != CPA_STATUS_SUCCESS) {
+			goto done;
+		}
+	} 
+	
+	else {
+		if (dir != QAT_DECOMPRESS) {
+			goto done;
+		}
+
+		/* 
+		 * In decompression scenario, this header will be jumped, 
+		 * leading hardware accelerator to start from content data. 
+		 */
+		buffer_list_src->pBuffers->pData += ZLIB_HEAD_SZ;
+		buffer_list_src->pBuffers->dataLenInBytes -= ZLIB_HEAD_SZ;
+
+		status = cpaDcDecompressData(
+		    inst_handle, dc_session_handle,
+		    buffer_list_src, buffer_list_dst,
+		    dc_results, CPA_DC_FLUSH_FINAL,
+		    dataKVIO);
+
+		if (status != CPA_STATUS_SUCCESS) {
+			goto done;
+		}
+	}
+
+	return status;
+
+done:
+	
+	QAT_PHYS_CONTIG_FREE(buffer_meta_src);
+	QAT_PHYS_CONTIG_FREE(buffer_meta_dst);
+	QAT_PHYS_CONTIG_FREE(buffer_list_src);
+	QAT_PHYS_CONTIG_FREE(buffer_list_dst);
+
+	if (dir == QAT_COMPRESS) {
+		/* 
+		 * If errors are occurred when sending request to hardware accelerator, 
+		 * this request will be interrupted and marked as incompressible data, 
+		 * and allocated memory will be freed before leaving the calling routine. 
+		 */
+		qat_add_cache_free(add);
+		DataVIO *dataVIO = &dataKVIO->dataVIO;
+		dataVIO->compression.size = VDO_BLOCK_SIZE + 1;
+		kvdoEnqueueDataVIOCallback(dataKVIO);
+	}
+	else {
+		/* 
+		 * In read workflow, if status is not success, 
+		 * the status field of readBlock will be marked as invalid fragment 
+		 * that indicated a read failure has occurred. 
+		 */
+		ReadBlock *readBlock = &dataKVIO->readBlock;
+		readBlock->status = VDO_INVALID_FRAGMENT;
+		readBlock->callback(dataKVIO);
+	}
+
+	return (status);
+}
+
+/**********************************************************************/
+/*
+ * Entry point for QAT accelerated compression / decompression.
+ */
+int qat_compress(DataKVIO* dataKVIO, qat_compress_dir_t dir, char *src, int src_len,
+    char *dst, int dst_len, size_t *c_len)
+{
+	int ret;
+	size_t add_len = 0;
+	
+	QATCallbackTag *tag = &dataKVIO->qatCallbackTag;
+	
+	tag->dir = dir;
+	if (dir == QAT_COMPRESS) {
+		tag->add = qat_add_cache_alloc();
+		add_len = VDO_BLOCK_SIZE;
+	}
+
+	ret = qat_compress_impl(dataKVIO, src, src_len, dst, dst_len, 
+				tag->add, add_len, c_len);
+
+	return (ret);
+}
+
diff --git a/vdo/kernel/qatInternals.h b/vdo/kernel/qatInternals.h
new file mode 100644
index 0000000..feb0d67
--- /dev/null
+++ b/vdo/kernel/qatInternals.h
@@ -0,0 +1,57 @@
+/*****************************************************************************
+ *
+ *   This file is provided under GPLv2 license.  When using or
+ *   redistributing this file, you may do so under GPL v2 license.
+ * 
+ *   GPL LICENSE SUMMARY
+ *   
+ *     Copyright(c) 2007-2020 Intel Corporation. All rights reserved.
+ *   
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of version 2 of the GNU General Public License as
+ *     published by the Free Software Foundation.
+
+ *     This program is distributed in the hope that it will be useful, but
+ *     WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *     General Public License for more details.
+
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *     The full GNU General Public License is included in this distribution
+ *     in the file called LICENSE.GPL.
+
+ *     Contact Information:
+ *     Intel Corporation 
+ *****************************************************************************/
+
+#ifndef _QAT_INTERNALS_H
+#define _QAT_INTERNALS_H
+
+#include "cpa.h"
+#include "dc/cpa_dc.h"
+
+typedef enum qat_compress_dir {
+	QAT_DECOMPRESS = 0,
+	QAT_COMPRESS = 1,
+} qat_compress_dir_t;
+
+typedef enum {
+	B_FALSE = 0,
+	B_TRUE = 1,
+} boolean_t;
+
+typedef struct
+{
+	CpaDcRqResults dc_results;
+	qat_compress_dir_t dir;
+	Cpa16U i;
+	Cpa8U *buffer_meta_src;
+	Cpa8U *buffer_meta_dst;
+	CpaBufferList *buffer_list_src;
+	CpaBufferList *buffer_list_dst;
+	char *add;
+} QATCallbackTag;
+
+#endif /* _QAT_INTERNALS_H  */
